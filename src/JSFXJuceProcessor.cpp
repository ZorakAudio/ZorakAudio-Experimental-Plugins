#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_gui_extra/juce_gui_extra.h>

#include <algorithm>
#include <array>
#include <cctype>
#include <cstdint>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <map>
#include <memory>
#include <regex>
#include <string>
#include <vector>

#include "JSFXDSP.h" // generated by dsp_jsfx_aot.py into the plugin build dir

// ---- You must provide this symbol for AOT (declared in the generated header)
extern "C" void jsfx_ensure_mem (DSPJSFX_State* st, int64_t needed);

// JSFX source is generated into the build dir by build.py as JSFXSource.h.
// If it's missing, we fall back to empty text (no slider params).
#if defined(__has_include)
  #if __has_include("JSFXSource.h")
    #include "JSFXSource.h"
  #else
    static const char* kJsfxSourceText = R"JSFX()JSFX";
  #endif
#else
  static const char* kJsfxSourceText = R"JSFX()JSFX";
#endif


// Global registry so jsfx_ensure_mem can realloc the correct block
namespace
{
static std::map<DSPJSFX_State*, double*> gMemOwner;
static std::map<DSPJSFX_State*, int64_t> gMemSize;

static juce::String sanitizeId (const juce::String& s)
{
    juce::String out;
    for (auto c : s)
    {
        if (juce::CharacterFunctions::isLetterOrDigit (c))
            out << c;
        else if (c == ' ' || c == '-' || c == '_')
            out << '_';
    }

    if (out.isEmpty())
        out = "param";

    return out;
}

struct JsfxSliderDecl
{
    int index0 = 0;
    juce::String id;
    juce::String name;
    float def  = 0.0f;
    float min  = 0.0f;
    float max  = 1.0f;
    float step = 0.001f;

    // Optional enum choices parsed from "step{A,B,C}" syntax
    juce::StringArray choices;
    bool isChoice = false;

    // Optional UI metadata parsed from JSFX comments
    //   // #TOOLTIP: ... (immediately above a slider line)
    juce::String tooltip;
};

static inline std::string trimAscii (std::string s)
{
    while (! s.empty() && std::isspace ((unsigned char) s.front()))
        s.erase (s.begin());
    while (! s.empty() && std::isspace ((unsigned char) s.back()))
        s.pop_back();
    return s;
}

// Split a JSFX "<min,max,step{...},skew>" range string on commas, but ignore commas inside { }.
// This is required because the enum-list itself is comma-separated.
static std::vector<std::string> splitTopLevelCommas (const std::string& s)
{
    std::vector<std::string> parts;
    std::string cur;
    int braceDepth = 0;

    for (char c : s)
    {
        if (c == '{')
            ++braceDepth;
        else if (c == '}' && braceDepth > 0)
            --braceDepth;

        if (c == ',' && braceDepth == 0)
        {
            parts.push_back (trimAscii (cur));
            cur.clear();
        }
        else
        {
            cur.push_back (c);
        }
    }

    parts.push_back (trimAscii (cur));
    return parts;
}

static bool parseFloat (const std::string& s, float& out)
{
    char* end = nullptr;
    const double v = std::strtod (s.c_str(), &end);
    if (end == s.c_str())
        return false;
    out = (float) v;
    return true;
}

// sliderN:DEF<MIN,MAX,STEP{,SKEW}>Label
// plus UI metadata comments:
//   // #TOOLTIP: ...  (applies to the next slider line)
//   // #HELP: ...     (can appear multiple times; concatenated with newlines)
static std::vector<JsfxSliderDecl> parseJsfxSliderDecls (const char* jsfxText, juce::String* outHelpText = nullptr)
{
    std::vector<JsfxSliderDecl> out;
    if (! jsfxText)
        return out;

    const std::regex reSlider (
        R"(^\s*slider\s*([0-9]{1,2})\s*:\s*([^<\r\n;]+)\s*(?:<\s*([^>]+)\s*>)?\s*(.*)$)",
        std::regex::ECMAScript);

    const std::regex reTooltip (R"(^\s*\/\/\s*#TOOLTIP:\s*(.*)$)", std::regex::ECMAScript);
    const std::regex reHelp    (R"(^\s*\/\/\s*#HELP:\s*(.*)$)",    std::regex::ECMAScript);

    juce::String pendingTooltip;
    juce::String helpAccum;

    std::string text (jsfxText);
    size_t start = 0;

    while (start < text.size())
    {
        size_t end = text.find_first_of ("\r\n", start);
        if (end == std::string::npos)
            end = text.size();

        std::string line = text.substr (start, end - start);

        size_t next = end;
        while (next < text.size() && (text[next] == '\r' || text[next] == '\n'))
            ++next;
        start = next;

        // --- UI metadata comments ---
        {
            std::smatch m;
            if (std::regex_match (line, m, reHelp))
            {
                auto part = juce::String::fromUTF8 (m[1].str().c_str()).trimEnd();
                if (! part.isEmpty())
                {
                    if (! helpAccum.isEmpty())
                        helpAccum << "\n";
                    helpAccum << part;
                }
                continue;
            }

            if (std::regex_match (line, m, reTooltip))
            {
                pendingTooltip = juce::String::fromUTF8 (m[1].str().c_str()).trim();
                continue;
            }
        }

        // --- Slider declarations ---
        std::smatch m;
        if (! std::regex_match (line, m, reSlider))
            continue;

        const int sliderN = std::atoi (m[1].str().c_str());
        if (sliderN < 1 || sliderN > 64)
            continue;

        JsfxSliderDecl d;
        d.index0 = sliderN - 1;
        d.id = "slider" + juce::String (sliderN);

        float def = 0.0f;
        if (! parseFloat (m[2].str(), def))
            def = 0.0f;
        d.def = def;

        if (m[3].matched)
        {
            std::string r = m[3].str();
            // IMPORTANT: do NOT naively split on ',' here.
            // JSFX enum syntax is step{A,B,C} which contains commas.
            const std::vector<std::string> parts = splitTopLevelCommas (r);

            float vmin = 0.0f, vmax = 1.0f, vstep = 0.001f;
            if (parts.size() >= 2)
            {
                if (! parseFloat (parts[0], vmin)) vmin = 0.0f;
                if (! parseFloat (parts[1], vmax)) vmax = 1.0f;
            }

            if (parts.size() >= 3)
            {
                // STEP token may be like "1{Eco,Moderate,High}".
                // Extract optional {choices} and parse the numeric prefix.
                std::string stepTok = parts[2];

                const auto bracePos = stepTok.find ('{');
                if (bracePos != std::string::npos)
                {
                    const auto closePos = stepTok.find ('}', bracePos + 1);
                    if (closePos != std::string::npos)
                    {
                        const auto inside = stepTok.substr (bracePos + 1, closePos - (bracePos + 1));
                        auto sInside = juce::String::fromUTF8 (inside.c_str());

                        juce::StringArray labels;
                        labels.addTokens (sInside, ",", "");
                        labels.trim();
                        labels.removeEmptyStrings();

                        if (labels.size() > 0)
                        {
                            d.choices = labels;
                            d.isChoice = true;
                        }
                    }

                    // Strip "{...}" for numeric parsing
                    stepTok = stepTok.substr (0, bracePos);
                    stepTok = trimAscii (stepTok);
                }

                // If stepTok is empty (e.g. "{A,B,C}"), JSFX semantics are effectively integer steps.
                if (stepTok.empty())
                    vstep = 1.0f;
                else if (! parseFloat (stepTok, vstep))
                    vstep = 1.0f;
            }

            if (vmax < vmin)
                std::swap (vmax, vmin);

            d.min  = vmin;
            d.max  = vmax;
            d.step = (vstep > 0.0f ? vstep : 0.001f);
            d.def  = juce::jlimit (d.min, d.max, d.def);
        }

        auto label = juce::String::fromUTF8 (m[4].str().c_str()).trim();
        if (label.isEmpty())
            label = "Slider " + juce::String (sliderN);

        d.name = label;
        d.tooltip = pendingTooltip;
        pendingTooltip.clear();

        out.push_back (d);
    }

    if (outHelpText)
        *outHelpText = helpAccum;

    std::sort (out.begin(), out.end(),
               [] (const JsfxSliderDecl& a, const JsfxSliderDecl& b) { return a.index0 < b.index0; });

    out.erase (std::unique (out.begin(), out.end(),
                            [] (const JsfxSliderDecl& a, const JsfxSliderDecl& b) { return a.index0 == b.index0; }),
               out.end());

    return out;
}
} // namespace


extern "C" void jsfx_ensure_mem (DSPJSFX_State* st, int64_t needed)
{
    if (! st)
        return;
    if (needed <= st->memN)
        return;

    int64_t newN = st->memN > 0 ? st->memN : 1024;
    while (newN < needed)
        newN = (newN * 3) / 2 + 64;

    const size_t oldBytes = (size_t) st->memN * sizeof (double);
    const size_t newBytes = (size_t) newN     * sizeof (double);

    void* p = std::realloc (st->mem, newBytes);
    if (! p)
        return;

    st->mem = (double*) p;

    if (newBytes > oldBytes)
        std::memset ((uint8_t*) p + oldBytes, 0, newBytes - oldBytes);

    st->memN = newN;

    gMemOwner[st] = st->mem;
    gMemSize [st] = st->memN;
}


class JSFXJuceEditor;


class JSFXJuceProcessor final : public juce::AudioProcessor
{
public:
    // Per-slider runtime metadata so we can map JUCE parameters back to the JSFX
    // numeric slider values (especially important for step{A,B,C} enums).
    struct SliderParamInfo
    {
        juce::String pid;
        float min  = 0.0f;
        float max  = 1.0f;
        float step = 1.0f;   // used for choice-index -> raw mapping
        bool isChoice = false;
    };

    JSFXJuceProcessor()
        : juce::AudioProcessor (BusesProperties()
              .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
              .withOutput ("Output", juce::AudioChannelSet::stereo(), true))
    {
        // Parse slider declarations + optional UI metadata from the JSFX source.
        // Tooltips:  // #TOOLTIP: ... (immediately above a slider line)
        // Help:      // #HELP: ...    (usually at the top of the file)
        sliderDecls = parseJsfxSliderDecls (kJsfxSourceText, &jsfxHelpText);

        // Reset runtime mapping tables (we only create parameters for declared sliders)
        sliderParamUsed.fill (false);

        juce::AudioProcessorValueTreeState::ParameterLayout layout;
        for (const auto& s : sliderDecls)
        {
            const auto pid = sanitizeId (s.id);

            // Record how this slider maps back into JSFX runtime values.
            // For AudioParameterChoice we store the original JSFX numeric min/max/step so we can
            // convert a choice index -> (min + index*step) at runtime.
            {
                SliderParamInfo info;
                info.pid      = pid;
                info.min      = s.min;
                info.max      = s.max;
                info.step     = (s.step > 0.0f ? s.step : 1.0f);
                info.isChoice = (s.isChoice && s.choices.size() > 0);
                sliderParamInfo[(size_t) s.index0] = info;
                sliderParamUsed[(size_t) s.index0] = true;
            }

            if (s.isChoice && s.choices.size() > 0)
            {
                // JSFX syntax: step{A,B,C} means *discrete* values, but the JSFX slider variable
                // is still numeric in the original range.
                //
                // We expose it as a CHOICE so hosts show the textual options.
                // Then at runtime we convert choice-index -> JSFX numeric value.
                const float step = (s.step > 0.0f ? s.step : 1.0f);
                int defIdx = (int) std::llround ((s.def - s.min) / step);
                defIdx = juce::jlimit (0, s.choices.size() - 1, defIdx);

                layout.add (std::make_unique<juce::AudioParameterChoice> (pid, s.name, s.choices, defIdx));
            }
            else
            {
                const auto range = juce::NormalisableRange<float> (s.min, s.max, s.step);
                layout.add (std::make_unique<juce::AudioParameterFloat> (pid, s.name, range, s.def));
            }
        }

        apvts = std::make_unique<juce::AudioProcessorValueTreeState> (*this, nullptr, "PARAMS", std::move (layout));

        paramAtomics.fill (nullptr);
        for (size_t i = 0; i < 64; ++i)
        {
            if (! sliderParamUsed[i])
                continue;
            const auto& info = sliderParamInfo[i];
            paramAtomics[i] = apvts->getRawParameterValue (info.pid);
        }

        initStateMemory();
    }

    ~JSFXJuceProcessor() override
    {
        gMemOwner.erase (&st);
        gMemSize.erase (&st);
        if (st.mem)
            std::free (st.mem);
    }

    const juce::String getName() const override
    {
    #if defined(ZA_PLUGIN_NAME)
        return ZA_PLUGIN_NAME;   // human name (can contain spaces/parentheses)
    #else
        return JucePlugin_Name;  // fallback
    #endif
    }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}

    void prepareToPlay (double sampleRate, int) override
    {
        resetStateStructOnly();
        st.srate = sampleRate;

        jsfx_init (&st);

        // Push params and run @slider once at startup
        lastSlidersValid = false;
        (void) pushParamsToStateSliders();
        jsfx_slider (&st);
    }

    void releaseResources() override {}

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override
    {
        const auto in  = layouts.getMainInputChannelSet();
        const auto out = layouts.getMainOutputChannelSet();
        if (in.isDisabled() || out.isDisabled()) return false;
        if (in.size() != out.size()) return false;
        return (in.size() >= 1 && in.size() <= 64);
    }

    void processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override
    {
        juce::ScopedNoDenormals _;

        const int numCh      = juce::jmin (buffer.getNumChannels(), 64);
        const int numSamples = buffer.getNumSamples();

        inPtrs.resize  ((size_t) numCh);
        outPtrs.resize ((size_t) numCh);

        for (int ch = 0; ch < numCh; ++ch)
        {
            inPtrs[(size_t) ch]  = buffer.getReadPointer (ch);
            outPtrs[(size_t) ch] = buffer.getWritePointer (ch);
        }

        const bool slidersChanged = pushParamsToStateSliders();
        if (slidersChanged)
            jsfx_slider (&st);

        jsfx_process_block (&st, inPtrs.data(), outPtrs.data(), numCh, numSamples);
    }

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    void getStateInformation (juce::MemoryBlock& destData) override
    {
        auto tree = apvts->copyState();
        std::unique_ptr<juce::XmlElement> xml (tree.createXml());
        copyXmlToBinary (*xml, destData);
    }

    void setStateInformation (const void* data, int sizeInBytes) override
    {
        std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
        if (xml && xml->hasTagName (apvts->state.getType()))
            apvts->replaceState (juce::ValueTree::fromXml (*xml));
    }

    // UI metadata accessors (used by the custom editor)
    const std::vector<JsfxSliderDecl>& getJsfxSliderDecls() const noexcept { return sliderDecls; }
    const juce::String& getJsfxHelpText() const noexcept { return jsfxHelpText; }

private:
    void initStateMemory()
    {
        std::memset (&st, 0, sizeof (st));
        const int64_t initialN = 2048;
        st.mem  = (double*) std::calloc ((size_t) initialN, sizeof (double));
        st.memN = (st.mem != nullptr ? initialN : 0);

        gMemOwner[&st] = st.mem;
        gMemSize [&st] = st.memN;
    }

    void resetStateStructOnly()
    {
        double* memKeep  = st.mem;
        int64_t memNKeep = st.memN;

        std::memset (&st, 0, sizeof (st));

        st.mem  = memKeep;
        st.memN = memNKeep;

        gMemOwner[&st] = st.mem;
        gMemSize [&st] = st.memN;
    }

    bool pushParamsToStateSliders()
    {
        bool changed = false;

        for (size_t i = 0; i < 64; ++i)
        {
            if (! sliderParamUsed[i])
                continue;

            const auto& info = sliderParamInfo[i];
            double newVal = st.sliders[i];

            // Robust value read:
            // - RangedAudioParameter::getValue() is ALWAYS normalised 0..1
            // - convertFrom0to1() ALWAYS returns the raw value in the parameter's declared range
            // This avoids accidentally feeding JSFX normalised values when the original slider
            // range was e.g. 0..100 or -24..+24.
            if (auto* v = paramAtomics[i])
            {
                // NOTE: For AudioParameterFloat, this returns the raw value in range.
                // For AudioParameterChoice, this returns the raw choice index.
                newVal = (double) v->load();
            }
            else if (auto* p = apvts->getParameter (info.pid))
            {
                const float norm = p->getValue();
                newVal = (double) p->convertFrom0to1 (norm);
            }

            // If the host-facing parameter is a CHOICE, its raw value is an index [0..N-1].
            // JSFX expects the original numeric slider value (min + index*step).
            if (info.isChoice)
            {
                const auto idx = (int64_t) std::llround (newVal);
                newVal = (double) info.min + (double) idx * (double) info.step;
            }

            // Clamp to the declared JSFX range.
            newVal = juce::jlimit<double> ((double) info.min, (double) info.max, newVal);

            // If this slider is not a CHOICE, emulate JSFX slider stepping.
            // This prevents host float jitter from triggering @slider rebuilds.
            if (! info.isChoice)
            {
                const double step = (double) (info.step > 0.0f ? info.step : 0.0f);
                if (step > 0.0)
                {
                    const double q = std::llround ((newVal - (double) info.min) / step);
                    newVal = (double) info.min + q * step;

                    // clamp again after quantize
                    newVal = juce::jlimit<double> ((double) info.min, (double) info.max, newVal);
                }
            }

            // Detect actual value change
            if (! lastSlidersValid || newVal != lastSliders[i])
            {
                changed = true;
                lastSliders[i] = newVal;
            }

            st.sliders[i] = newVal;
        }

        lastSlidersValid = true;
        return changed;
    }

    DSPJSFX_State st {};
    std::unique_ptr<juce::AudioProcessorValueTreeState> apvts;
    std::array<std::atomic<float>*, 64> paramAtomics {};

    std::vector<JsfxSliderDecl> sliderDecls;
    juce::String jsfxHelpText;

    std::array<SliderParamInfo, 64> sliderParamInfo {};
    std::array<bool, 64>           sliderParamUsed {};

    std::vector<const float*> inPtrs;
    std::vector<float*> outPtrs;
    std::array<double, 64> lastSliders {};
    bool lastSlidersValid = false;
};


// ============================================================
// Custom editor: bounded HELP overlay + row-hover tooltips sourced from JSFX comments.
// ============================================================
class JSFXJuceEditor final : public juce::AudioProcessorEditor,
                             private juce::Timer
{
public:
    explicit JSFXJuceEditor (JSFXJuceProcessor& p)
        : juce::AudioProcessorEditor (&p)
        , processor (p)
        , genericEditor (p)
    {
        addAndMakeVisible (genericEditor);

        // --- Help button (top-right) ---
        helpButton.setButtonText ("?");
        helpButton.setTooltip ("Show help");
        helpButton.onClick = [this]
        {
            if (helpOverlay.isVisible())
                hideHelp();
            else
                showHelp();
        };
        addAndMakeVisible (helpButton);

        // --- Help overlay (bounded inside editor) ---
        addChildComponent (helpOverlay);
        helpOverlay.setVisible (false);

        // --- Tooltip bubble ---
        addChildComponent (tooltipBubble);
        tooltipBubble.setVisible (false);
        tooltipBubble.setInterceptsMouseClicks (false, false);

        // Build row tooltip map from label texts
        rebuildRowTooltipMap();

        // Mouse tracking for row-hover tooltip behaviour
        genericEditor.addMouseListener (this, true);

        // Timer drives idle-delay + show/hide
        startTimerHz (30);

        // Match the generic editor size.
        setSize (genericEditor.getWidth(), genericEditor.getHeight());
    }

    void resized() override
    {
        genericEditor.setBounds (getLocalBounds());

        const int btnSize = 24;
        helpButton.setBounds (getWidth() - btnSize - 8, 8, btnSize, btnSize);
        helpButton.toFront (false);

        helpOverlay.setBounds (getLocalBounds());
        tooltipBubble.toFront (false);
    }

private:
    // -----------------------
    // HELP overlay component
    // -----------------------
    class HelpOverlay final : public juce::Component
    {
    public:
        HelpOverlay()
        {
            title.setText ("HELP", juce::dontSendNotification);
            title.setJustificationType (juce::Justification::centredLeft);
            title.setFont (juce::Font (16.0f, juce::Font::bold));
            addAndMakeVisible (title);

            close.setButtonText ("X");
            close.onClick = [this] { setVisible (false); };
            addAndMakeVisible (close);

            body.setMultiLine (true);
            body.setReadOnly (true);
            body.setScrollbarsShown (true);
            body.setCaretVisible (false);
            body.setPopupMenuEnabled (true);
            addAndMakeVisible (body);

            setWantsKeyboardFocus (true);
        }

        void setHelpText (const juce::String& t)
        {
            body.setText (t);
            body.setCaretPosition (0);
        }

        void paint (juce::Graphics& g) override
        {
            // Dim the background
            g.fillAll (juce::Colours::black.withAlpha (0.55f));

            // Panel
            auto panel = panelBounds.toFloat();
            g.setColour (juce::Colours::darkgrey.withAlpha (0.95f));
            g.fillRoundedRectangle (panel, 10.0f);

            g.setColour (juce::Colours::white.withAlpha (0.25f));
            g.drawRoundedRectangle (panel, 10.0f, 1.5f);
        }

        void resized() override
        {
            auto r = getLocalBounds();

            // A panel that always stays within the editor bounds.
            const int margin = 24;
            const int minW   = 420;
            const int minH   = 220;

            auto panel = r.reduced (margin);
            panel.setSize (juce::jmax (minW, panel.getWidth()), juce::jmax (minH, panel.getHeight()));
            panel = panel.withCentre (r.getCentre());
            panelBounds = panel;

            auto inner = panel.reduced (14);
            auto top = inner.removeFromTop (24);
            close.setBounds (top.removeFromRight (24));
            title.setBounds (top);
            inner.removeFromTop (10);
            body.setBounds (inner);
        }

        void mouseUp (const juce::MouseEvent& e) override
        {
            // Click outside the panel closes it.
            if (! panelBounds.contains (e.getPosition()))
                setVisible (false);
        }

    private:
        juce::Rectangle<int> panelBounds;
        juce::Label title;
        juce::TextButton close;
        juce::TextEditor body;
    };

    // -----------------------
    // Tooltip bubble component
    // -----------------------
    class TooltipBubble final : public juce::Component
    {
    public:
        void setText (const juce::String& newText)
        {
            if (text == newText)
                return;
            text = newText;
            rebuildLayout();
        }

        juce::Point<int> getBubbleSize() const noexcept
        {
            return bubbleSize;
        }

        void paint (juce::Graphics& g) override
        {
            auto r = getLocalBounds().toFloat();
            g.setColour (juce::Colours::black.withAlpha (0.85f));
            g.fillRoundedRectangle (r, 8.0f);
            g.setColour (juce::Colours::white.withAlpha (0.25f));
            g.drawRoundedRectangle (r, 8.0f, 1.2f);

            g.setColour (juce::Colours::white);

            auto textArea = getLocalBounds().reduced (padding);
            layout.draw (g, textArea.toFloat());
        }

    private:
        void rebuildLayout()
        {
            const int maxTextWidth = 360;
            const auto font = juce::Font (14.0f);

            juce::AttributedString as;
            as.setJustification (juce::Justification::topLeft);
            as.append (text, font, juce::Colours::white);

            layout = juce::TextLayout();
            layout.createLayout (as, (float) maxTextWidth);

            const int h = (int) std::ceil (layout.getHeight());
            bubbleSize = { maxTextWidth + padding * 2, h + padding * 2 };
            setSize (bubbleSize.x, bubbleSize.y);
        }

        juce::String text;
        juce::TextLayout layout;
        juce::Point<int> bubbleSize { 0, 0 };
        static constexpr int padding = 10;
    };

    // -----------------------
    // Tooltip behaviour
    // -----------------------
    void rebuildRowTooltipMap()
    {
        tooltipByLabel.clear();
        rowTooltipByRow.clear();

        for (const auto& s : processor.getJsfxSliderDecls())
        {
            if (! s.tooltip.isEmpty())
                tooltipByLabel[s.name.trim()] = s.tooltip.trim();
        }

        // Recursively scan labels in the generic editor; map label->parent row component.
        scanForRows (genericEditor);
    }

    void scanForRows (juce::Component& c)
    {
        if (auto* label = dynamic_cast<juce::Label*> (&c))
        {
            const auto key = label->getText().trim();
            auto it = tooltipByLabel.find (key);
            if (it != tooltipByLabel.end())
            {
                if (auto* row = label->getParentComponent())
                    rowTooltipByRow[row] = it->second;
            }
        }

        for (int i = 0; i < c.getNumChildComponents(); ++i)
            scanForRows (*c.getChildComponent (i));
    }

    juce::Component* findRowForComponent (juce::Component* c) const
    {
        // Walk up parents until we find a row component we've registered.
        while (c != nullptr && c != &genericEditor)
        {
            auto it = rowTooltipByRow.find (c);
            if (it != rowTooltipByRow.end())
                return c;
            c = c->getParentComponent();
        }
        return nullptr;
    }

    void showTooltipForCurrentRow()
    {
        if (currentRow == nullptr)
            return;

        auto it = rowTooltipByRow.find (currentRow);
        if (it == rowTooltipByRow.end())
            return;

        const auto text = it->second;
        if (text.isEmpty())
            return;

        tooltipBubble.setText (text);
        tooltipBubble.setVisible (true);
        tooltipBubble.toFront (false);
        positionTooltipAt (lastMousePos);
    }

    void hideTooltip()
    {
        tooltipBubble.setVisible (false);
    }

    void positionTooltipAt (juce::Point<int> mousePos)
    {
        auto size = tooltipBubble.getBubbleSize();
        if (size.x <= 0 || size.y <= 0)
            return;

        // "Constantly centered at the mouse" (as requested)
        int x = mousePos.x - size.x / 2;
        int y = mousePos.y - size.y / 2;

        // Keep within editor bounds so it never renders outside.
        x = juce::jlimit (0, getWidth()  - size.x, x);
        y = juce::jlimit (0, getHeight() - size.y, y);

        tooltipBubble.setBounds (x, y, size.x, size.y);
    }

    // -----------------------
    // MouseListener / Timer
    // -----------------------
    void mouseMove (const juce::MouseEvent& e) override
    {
        if (helpOverlay.isVisible())
            return;

        // Suppress tooltip logic while dragging/holding mouse buttons.
        if (e.mods.isAnyMouseButtonDown())
        {
            hideTooltip();
            return;
        }

        const auto now = juce::Time::getMillisecondCounter();
        lastMoveMs = now;
        lastMousePos = e.getEventRelativeTo (this).getPosition();

        auto* row = findRowForComponent (e.eventComponent);
        if (row != currentRow)
        {
            currentRow = row;
            hideTooltip();
        }

        // If tooltip is already visible, make it follow the mouse.
        if (tooltipBubble.isVisible())
            positionTooltipAt (lastMousePos);
    }

    void mouseDrag (const juce::MouseEvent&) override
    {
        // While dragging a control, tooltips are more annoying than helpful.
        hideTooltip();
    }

    void timerCallback() override
    {
        // Hide tooltip if help is open.
        if (helpOverlay.isVisible())
        {
            hideTooltip();
            return;
        }

        // Hide while any mouse button is down.
        if (juce::ModifierKeys::getCurrentModifiers().isAnyMouseButtonDown())
        {
            hideTooltip();
            return;
        }

        // If the mouse is no longer inside the generic editor, clear row.
        const auto mp = getMouseXYRelative();
        if (! genericEditor.getBounds().contains (mp))
        {
            currentRow = nullptr;
            hideTooltip();
            return;
        }

        if (currentRow == nullptr)
        {
            hideTooltip();
            return;
        }

        const auto now = juce::Time::getMillisecondCounter();
        const auto elapsed = (uint32_t) (now - lastMoveMs);

        // Show only after 3 seconds of mouse-idle (requested behaviour).
        if (! tooltipBubble.isVisible())
        {
            if (elapsed >= idleDelayMs)
                showTooltipForCurrentRow();
        }
        else
        {
            // Keep it centered at last known mouse pos.
            positionTooltipAt (lastMousePos);
        }
    }

    // -----------------------
    // HELP show/hide
    // -----------------------
    void showHelp()
    {
        hideTooltip();

        auto help = processor.getJsfxHelpText();
        if (help.isEmpty())
            help = "No help text found. Add one or more lines like:\n\n// #HELP: Your description here";

        helpOverlay.setHelpText (help);
        helpOverlay.setVisible (true);
        helpOverlay.toFront (true);
        helpOverlay.grabKeyboardFocus();
        resized();
    }

    void hideHelp()
    {
        helpOverlay.setVisible (false);
    }

    JSFXJuceProcessor& processor;
    juce::GenericAudioProcessorEditor genericEditor;

    juce::TextButton helpButton;
    HelpOverlay helpOverlay;

    TooltipBubble tooltipBubble;

    std::map<juce::String, juce::String> tooltipByLabel;
    std::map<juce::Component*, juce::String> rowTooltipByRow;

    juce::Component* currentRow = nullptr;
    juce::Point<int> lastMousePos { 0, 0 };
    uint32_t lastMoveMs = 0;
    static constexpr uint32_t idleDelayMs = 3000;
};


juce::AudioProcessorEditor* JSFXJuceProcessor::createEditor()
{
    return new JSFXJuceEditor (*this);
}


juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JSFXJuceProcessor();
}
