#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_gui_extra/juce_gui_extra.h>

#include <algorithm>
#include <cctype>
#include <cstdint>
#include <cstdlib>
#include <map>
#include <regex>
#include <string>
#include <vector>

#include "JSFXDSP.h" // generated by dsp_jsfx_aot.py into the plugin build dir

// ---- You must provide this symbol for AOT (declared in the generated header)
extern "C" void jsfx_ensure_mem (DSPJSFX_State* st, int64_t needed);

// JSFX source is generated into the build dir by build.py as JSFXSource.h.
// If it's missing, we fall back to empty text (no slider params).
#if defined(__has_include)
  #if __has_include("JSFXSource.h")
    #include "JSFXSource.h"
  #else
    static const char* kJsfxSourceText = R"JSFX()JSFX";
  #endif
#else
  static const char* kJsfxSourceText = R"JSFX()JSFX";
#endif


// Global registry so jsfx_ensure_mem can realloc the correct block
namespace {
static std::map<DSPJSFX_State*, double*> gMemOwner;
static std::map<DSPJSFX_State*, int64_t> gMemSize;

static juce::String sanitizeId (const juce::String& s)
{
    juce::String out;
    for (auto c : s)
    {
        if (juce::CharacterFunctions::isLetterOrDigit (c)) out << c;
        else if (c == ' ' || c == '-' || c == '_') out << '_';
    }
    if (out.isEmpty()) out = "param";
    return out;
}

struct JsfxSliderDecl
{
    int index0 = 0;
    juce::String id;
    juce::String name;
    float def  = 0.0f;
    float min  = 0.0f;
    float max  = 1.0f;
    float step = 0.001f;

    // Optional enum choices parsed from "step{A,B,C}" syntax
    juce::StringArray choices;
    bool isChoice = false;
};


static bool parseFloat (const std::string& s, float& out)
{
    char* end = nullptr;
    const double v = std::strtod (s.c_str(), &end);
    if (end == s.c_str()) return false;
    out = (float) v;
    return true;
}

// sliderN:DEF<MIN,MAX,STEP{,SKEW}>Label
static std::vector<JsfxSliderDecl> parseJsfxSliderDecls (const char* jsfxText)
{
    std::vector<JsfxSliderDecl> out;
    if (!jsfxText) return out;

    const std::regex re(
        R"(^\s*slider\s*([0-9]{1,2})\s*:\s*([^<\r\n;]+)\s*(?:<\s*([^>]+)\s*>)?\s*(.*)$)",
        std::regex::ECMAScript
    );

    std::string text (jsfxText);
    size_t start = 0;

    while (start < text.size())
    {
        size_t end = text.find_first_of ("\r\n", start);
        if (end == std::string::npos) end = text.size();
        std::string line = text.substr (start, end - start);

        size_t next = end;
        while (next < text.size() && (text[next] == '\r' || text[next] == '\n')) ++next;
        start = next;

        std::smatch m;
        if (!std::regex_match (line, m, re)) continue;

        const int sliderN = std::atoi (m[1].str().c_str());
        if (sliderN < 1 || sliderN > 64) continue;

        JsfxSliderDecl d;
        d.index0 = sliderN - 1;
        d.id = "slider" + juce::String (sliderN);

        float def = 0.0f;
        if (!parseFloat (m[2].str(), def)) def = 0.0f;
        d.def = def;

        if (m[3].matched)
        {
            std::string r = m[3].str();
            std::vector<std::string> parts;
            size_t p0 = 0;
            while (p0 < r.size())
            {
                size_t p1 = r.find (',', p0);
                if (p1 == std::string::npos) p1 = r.size();
                auto token = r.substr (p0, p1 - p0);

                while (!token.empty() && std::isspace ((unsigned char) token.front())) token.erase (token.begin());
                while (!token.empty() && std::isspace ((unsigned char) token.back()))  token.pop_back();

                parts.push_back (token);
                p0 = p1 + 1;
            }

            float vmin = 0.0f, vmax = 1.0f, vstep = 0.001f;
            if (parts.size() >= 2)
            {
                if (!parseFloat (parts[0], vmin)) vmin = 0.0f;
                if (!parseFloat (parts[1], vmax)) vmax = 1.0f;
            }
            if (parts.size() >= 3)
            {
                // STEP token may be like "1{Eco,Moderate,High}".
                // Extract optional {choices} and parse the numeric prefix.
                std::string stepTok = parts[2];

                auto bracePos = stepTok.find('{');
                if (bracePos != std::string::npos)
                {
                    auto closePos = stepTok.find('}', bracePos + 1);
                    if (closePos != std::string::npos)
                    {
                        // Parse labels inside braces
                        auto inside = stepTok.substr(bracePos + 1, closePos - (bracePos + 1));
                        juce::String sInside = juce::String::fromUTF8(inside.c_str());

                        juce::StringArray labels;
                        labels.addTokens(sInside, ",", "");
                        labels.trim();
                        labels.removeEmptyStrings();

                        if (labels.size() > 0)
                        {
                            d.choices = labels;
                            d.isChoice = true;
                        }
                    }

                    // Strip "{...}" for numeric parsing
                    stepTok = stepTok.substr(0, bracePos);
                    // trim
                    while (!stepTok.empty() && std::isspace((unsigned char)stepTok.front())) stepTok.erase(stepTok.begin());
                    while (!stepTok.empty() && std::isspace((unsigned char)stepTok.back()))  stepTok.pop_back();
                }

                if (!parseFloat(stepTok, vstep)) vstep = 1.0f;
            }


            if (vmax < vmin) std::swap (vmax, vmin);
            d.min = vmin;
            d.max = vmax;
            d.step = (vstep > 0.0f ? vstep : 0.001f);
            d.def = juce::jlimit (d.min, d.max, d.def);
        }

        auto label = juce::String::fromUTF8 (m[4].str().c_str()).trim();
        if (label.isEmpty()) label = "Slider " + juce::String (sliderN);
        d.name = label;

        out.push_back (d);
    }

    std::sort (out.begin(), out.end(),
               [] (const JsfxSliderDecl& a, const JsfxSliderDecl& b) { return a.index0 < b.index0; });

    out.erase (std::unique (out.begin(), out.end(),
                            [] (const JsfxSliderDecl& a, const JsfxSliderDecl& b) { return a.index0 == b.index0; }),
               out.end());

    return out;
}
} // namespace


extern "C" void jsfx_ensure_mem (DSPJSFX_State* st, int64_t needed)
{
    if (!st) return;
    if (needed <= st->memN) return;

    int64_t newN = st->memN > 0 ? st->memN : 1024;
    while (newN < needed) newN = (newN * 3) / 2 + 64;

    const size_t oldBytes = (size_t) st->memN * sizeof(double);
    const size_t newBytes = (size_t) newN     * sizeof(double);

    void* p = std::realloc (st->mem, newBytes);
    if (!p) return;

    st->mem = (double*) p;

    if (newBytes > oldBytes)
        std::memset ((uint8_t*) p + oldBytes, 0, newBytes - oldBytes);

    st->memN = newN;

    gMemOwner[st] = st->mem;
    gMemSize [st] = st->memN;
}


class JSFXJuceProcessor final : public juce::AudioProcessor
{
public:
    JSFXJuceProcessor()
        : juce::AudioProcessor (BusesProperties()
            .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
            .withOutput ("Output", juce::AudioChannelSet::stereo(), true))
    {
        sliderDecls = parseJsfxSliderDecls (kJsfxSourceText);

        juce::AudioProcessorValueTreeState::ParameterLayout layout;
        for (const auto& s : sliderDecls)
        {
            const auto pid = sanitizeId (s.id);

            if (s.isChoice && s.choices.size() > 0)
            {
                // Map JSFX numeric range [min..max] to choice index [0..N-1]
                const int base = (int) std::floor(s.min + 0.5f);
                int defIdx = (int) std::floor((s.def - (float)base) + 0.5f);
                defIdx = juce::jlimit(0, s.choices.size() - 1, defIdx);

                layout.add (std::make_unique<juce::AudioParameterChoice>(pid, s.name, s.choices, defIdx));
            }
            else
            {
                const auto range = juce::NormalisableRange<float> (s.min, s.max, s.step);
                layout.add (std::make_unique<juce::AudioParameterFloat> (pid, s.name, range, s.def));
            }

            paramIdBySliderIndex[s.index0] = pid;
        }


        apvts = std::make_unique<juce::AudioProcessorValueTreeState> (*this, nullptr, "PARAMS", std::move (layout));

        initStateMemory();
    }

    ~JSFXJuceProcessor() override
    {
        gMemOwner.erase (&st);
        gMemSize.erase (&st);
        if (st.mem) std::free (st.mem);
    }

    const juce::String getName() const override { return JucePlugin_Name; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}

    void prepareToPlay (double sampleRate, int) override
    {
        resetStateStructOnly();
        st.srate = sampleRate;

        jsfx_init (&st);
        pushParamsToStateSliders();
    }

    void releaseResources() override {}

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override
    {
        const auto in  = layouts.getMainInputChannelSet();
        const auto out = layouts.getMainOutputChannelSet();
        if (in.isDisabled() || out.isDisabled()) return false;
        if (in.size() != out.size()) return false;
        return (in.size() >= 1 && in.size() <= 64);
    }

    void processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override
    {
        juce::ScopedNoDenormals _;

        const int numCh = juce::jmin (buffer.getNumChannels(), 64);
        const int numSamples = buffer.getNumSamples();

        inPtrs.resize  ((size_t) numCh);
        outPtrs.resize ((size_t) numCh);

        for (int ch = 0; ch < numCh; ++ch)
        {
            inPtrs[(size_t) ch]  = buffer.getReadPointer (ch);
            outPtrs[(size_t) ch] = buffer.getWritePointer (ch);
        }

        pushParamsToStateSliders();

        jsfx_process_block (&st, inPtrs.data(), outPtrs.data(), numCh, numSamples);
    }

    juce::AudioProcessorEditor* createEditor() override { return new juce::GenericAudioProcessorEditor (*this); }
    bool hasEditor() const override { return true; }

    void getStateInformation (juce::MemoryBlock& destData) override
    {
        auto tree = apvts->copyState();
        std::unique_ptr<juce::XmlElement> xml (tree.createXml());
        copyXmlToBinary (*xml, destData);
    }

    void setStateInformation (const void* data, int sizeInBytes) override
    {
        std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
        if (xml && xml->hasTagName (apvts->state.getType()))
            apvts->replaceState (juce::ValueTree::fromXml (*xml));
    }

private:
    void initStateMemory()
    {
        std::memset (&st, 0, sizeof (st));
        const int64_t initialN = 2048;
        st.mem  = (double*) std::calloc ((size_t) initialN, sizeof(double));
        st.memN = (st.mem != nullptr ? initialN : 0);

        gMemOwner[&st] = st.mem;
        gMemSize [&st] = st.memN;
    }

    void resetStateStructOnly()
    {
        double* memKeep = st.mem;
        int64_t memNKeep = st.memN;

        std::memset (&st, 0, sizeof (st));

        st.mem  = memKeep;
        st.memN = memNKeep;

        gMemOwner[&st] = st.mem;
        gMemSize [&st] = st.memN;
    }

    void pushParamsToStateSliders()
    {
        for (const auto& kv : paramIdBySliderIndex)
        {
            const int idx0 = kv.first;
            const auto& pid = kv.second;

            auto it = std::find_if(sliderDecls.begin(), sliderDecls.end(),
                                [idx0](const JsfxSliderDecl& d){ return d.index0 == idx0; });

            const bool isChoice = (it != sliderDecls.end() && it->isChoice && it->choices.size() > 0);
            const int base = isChoice ? (int) std::floor(it->min + 0.5f) : 0;

            if (auto* p = apvts->getParameter(pid))
            {
                if (isChoice)
                {
                    // Convert normalized -> choice index
                    auto* cp = dynamic_cast<juce::AudioParameterChoice*>(p);
                    const int choiceIdx = cp ? cp->getIndex() : (int) std::floor(p->getValue() + 0.5f);
                    st.sliders[idx0] = (double) (base + choiceIdx);
                }
                else
                {
                    if (auto* v = apvts->getRawParameterValue(pid))
                        st.sliders[idx0] = (double) v->load();
                }
            }
        }
    }


private:
    DSPJSFX_State st {};
    std::unique_ptr<juce::AudioProcessorValueTreeState> apvts;

    std::vector<JsfxSliderDecl> sliderDecls;
    std::map<int, juce::String> paramIdBySliderIndex;

    std::vector<const float*> inPtrs;
    std::vector<float*> outPtrs;
};


juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JSFXJuceProcessor();
}
