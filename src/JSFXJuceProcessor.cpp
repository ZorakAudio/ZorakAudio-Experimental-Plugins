#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_gui_extra/juce_gui_extra.h>

#include <algorithm>
#include <cctype>
#include <cstdint>
#include <cstdlib>
#include <map>
#include <regex>
#include <string>
#include <vector>
#include <array>
#include <cmath>


#include "JSFXDSP.h" // generated by dsp_jsfx_aot.py into the plugin build dir

// ---- You must provide this symbol for AOT (declared in the generated header)
extern "C" void jsfx_ensure_mem (DSPJSFX_State* st, int64_t needed);

// JSFX source is generated into the build dir by build.py as JSFXSource.h.
// If it's missing, we fall back to empty text (no slider params).
#if defined(__has_include)
  #if __has_include("JSFXSource.h")
    #include "JSFXSource.h"
  #else
    static const char* kJsfxSourceText = R"JSFX()JSFX";
  #endif
#else
  static const char* kJsfxSourceText = R"JSFX()JSFX";
#endif


// Global registry so jsfx_ensure_mem can realloc the correct block
namespace {
static std::map<DSPJSFX_State*, double*> gMemOwner;
static std::map<DSPJSFX_State*, int64_t> gMemSize;

static juce::String sanitizeId (const juce::String& s)
{
    juce::String out;
    for (auto c : s)
    {
        if (juce::CharacterFunctions::isLetterOrDigit (c)) out << c;
        else if (c == ' ' || c == '-' || c == '_') out << '_';
    }
    if (out.isEmpty()) out = "param";
    return out;
}

struct JsfxSliderDecl
{
    int index0 = 0;
    juce::String id;
    juce::String name;
    float def  = 0.0f;
    float min  = 0.0f;
    float max  = 1.0f;
    float step = 0.001f;

    // Optional enum choices parsed from "step{A,B,C}" syntax
    juce::StringArray choices;
    bool isChoice = false;
};

static inline std::string trimAscii (std::string s)
{
    while (!s.empty() && std::isspace ((unsigned char) s.front())) s.erase (s.begin());
    while (!s.empty() && std::isspace ((unsigned char) s.back()))  s.pop_back();
    return s;
}

// Split a JSFX "<min,max,step{...},skew>" range string on commas, but ignore commas inside { }.
// This is required because the enum-list itself is comma-separated.
static std::vector<std::string> splitTopLevelCommas (const std::string& s)
{
    std::vector<std::string> parts;
    std::string cur;
    int braceDepth = 0;

    for (char c : s)
    {
        if (c == '{')
            ++braceDepth;
        else if (c == '}' && braceDepth > 0)
            --braceDepth;

        if (c == ',' && braceDepth == 0)
        {
            parts.push_back (trimAscii (cur));
            cur.clear();
        }
        else
        {
            cur.push_back (c);
        }
    }

    parts.push_back (trimAscii (cur));
    return parts;
}


static bool parseFloat (const std::string& s, float& out)
{
    char* end = nullptr;
    const double v = std::strtod (s.c_str(), &end);
    if (end == s.c_str()) return false;
    out = (float) v;
    return true;
}

// sliderN:DEF<MIN,MAX,STEP{,SKEW}>Label
static std::vector<JsfxSliderDecl> parseJsfxSliderDecls (const char* jsfxText)
{
    std::vector<JsfxSliderDecl> out;
    if (!jsfxText) return out;

    const std::regex re(
        R"(^\s*slider\s*([0-9]{1,2})\s*:\s*([^<\r\n;]+)\s*(?:<\s*([^>]+)\s*>)?\s*(.*)$)",
        std::regex::ECMAScript
    );

    std::string text (jsfxText);
    size_t start = 0;

    while (start < text.size())
    {
        size_t end = text.find_first_of ("\r\n", start);
        if (end == std::string::npos) end = text.size();
        std::string line = text.substr (start, end - start);

        size_t next = end;
        while (next < text.size() && (text[next] == '\r' || text[next] == '\n')) ++next;
        start = next;

        std::smatch m;
        if (!std::regex_match (line, m, re)) continue;

        const int sliderN = std::atoi (m[1].str().c_str());
        if (sliderN < 1 || sliderN > 64) continue;

        JsfxSliderDecl d;
        d.index0 = sliderN - 1;
        d.id = "slider" + juce::String (sliderN);

        float def = 0.0f;
        if (!parseFloat (m[2].str(), def)) def = 0.0f;
        d.def = def;

        if (m[3].matched)
        {
            std::string r = m[3].str();
            // IMPORTANT: do NOT naively split on ',' here.
            // JSFX enum syntax is step{A,B,C} which contains commas.
            const std::vector<std::string> parts = splitTopLevelCommas (r);

            float vmin = 0.0f, vmax = 1.0f, vstep = 0.001f;
            if (parts.size() >= 2)
            {
                if (!parseFloat (parts[0], vmin)) vmin = 0.0f;
                if (!parseFloat (parts[1], vmax)) vmax = 1.0f;
            }
            if (parts.size() >= 3)
            {
                // STEP token may be like "1{Eco,Moderate,High}".
                // Extract optional {choices} and parse the numeric prefix.
                std::string stepTok = parts[2];

                auto bracePos = stepTok.find('{');
                if (bracePos != std::string::npos)
                {
                    auto closePos = stepTok.find('}', bracePos + 1);
                    if (closePos != std::string::npos)
                    {
                        // Parse labels inside braces
                        auto inside = stepTok.substr(bracePos + 1, closePos - (bracePos + 1));
                        juce::String sInside = juce::String::fromUTF8(inside.c_str());

                        juce::StringArray labels;
                        labels.addTokens(sInside, ",", "");
                        labels.trim();
                        labels.removeEmptyStrings();

                        if (labels.size() > 0)
                        {
                            d.choices = labels;
                            d.isChoice = true;
                        }
                    }

                    // Strip "{...}" for numeric parsing
                    stepTok = stepTok.substr(0, bracePos);
                    stepTok = trimAscii (stepTok);
                }

                // If stepTok is empty (e.g. "{A,B,C}"), JSFX semantics are effectively integer steps.
                if (stepTok.empty()) vstep = 1.0f;
                else if (!parseFloat(stepTok, vstep)) vstep = 1.0f;
            }


            if (vmax < vmin) std::swap (vmax, vmin);
            d.min = vmin;
            d.max = vmax;
            d.step = (vstep > 0.0f ? vstep : 0.001f);
            d.def = juce::jlimit (d.min, d.max, d.def);
        }

        auto label = juce::String::fromUTF8 (m[4].str().c_str()).trim();
        if (label.isEmpty()) label = "Slider " + juce::String (sliderN);
        d.name = label;

        out.push_back (d);
    }

    std::sort (out.begin(), out.end(),
               [] (const JsfxSliderDecl& a, const JsfxSliderDecl& b) { return a.index0 < b.index0; });

    out.erase (std::unique (out.begin(), out.end(),
                            [] (const JsfxSliderDecl& a, const JsfxSliderDecl& b) { return a.index0 == b.index0; }),
               out.end());

    return out;
}
} // namespace


extern "C" void jsfx_ensure_mem (DSPJSFX_State* st, int64_t needed)
{
    if (!st) return;
    if (needed <= st->memN) return;

    int64_t newN = st->memN > 0 ? st->memN : 1024;
    while (newN < needed) newN = (newN * 3) / 2 + 64;

    const size_t oldBytes = (size_t) st->memN * sizeof(double);
    const size_t newBytes = (size_t) newN     * sizeof(double);

    void* p = std::realloc (st->mem, newBytes);
    if (!p) return;

    st->mem = (double*) p;

    if (newBytes > oldBytes)
        std::memset ((uint8_t*) p + oldBytes, 0, newBytes - oldBytes);

    st->memN = newN;

    gMemOwner[st] = st->mem;
    gMemSize [st] = st->memN;
}


class JSFXJuceProcessor final : public juce::AudioProcessor
{
public:
    // Per-slider runtime metadata so we can map JUCE parameters back to the JSFX
    // numeric slider values (especially important for step{A,B,C} enums).
    struct SliderParamInfo
    {
        juce::String pid;
        float min  = 0.0f;
        float max  = 1.0f;
        float step = 1.0f;   // used for choice-index -> raw mapping
        bool isChoice = false;
    };

    JSFXJuceProcessor()
        : juce::AudioProcessor (BusesProperties()
            .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
            .withOutput ("Output", juce::AudioChannelSet::stereo(), true))
    {
        sliderDecls = parseJsfxSliderDecls (kJsfxSourceText);

        // Reset runtime mapping tables (we only create parameters for declared sliders)
        sliderParamUsed.fill (false);

        juce::AudioProcessorValueTreeState::ParameterLayout layout;
        for (const auto& s : sliderDecls)
        {
            const auto pid = sanitizeId (s.id);

            // Record how this slider maps back into JSFX runtime values.
            // For AudioParameterChoice we store the original JSFX numeric min/max/step so we can
            // convert a choice index -> (min + index*step) at runtime.
            {
                SliderParamInfo info;
                info.pid      = pid;
                info.min      = s.min;
                info.max      = s.max;
                info.step     = (s.step > 0.0f ? s.step : 1.0f);
                info.isChoice = (s.isChoice && s.choices.size() > 0);
                sliderParamInfo[(size_t) s.index0] = info;
                sliderParamUsed[(size_t) s.index0] = true;
            }

            if (s.isChoice && s.choices.size() > 0)
            {
                // JSFX syntax: step{A,B,C} means *discrete* values, but the JSFX slider variable
                // is still numeric in the original range.
                //
                // We expose it as a CHOICE so hosts show the textual options.
                // Then at runtime we convert choice-index -> JSFX numeric value.
                const float step = (s.step > 0.0f ? s.step : 1.0f);
                int defIdx = (int) std::llround ((s.def - s.min) / step);
                defIdx = juce::jlimit(0, s.choices.size() - 1, defIdx);

                layout.add (std::make_unique<juce::AudioParameterChoice>(pid, s.name, s.choices, defIdx));
            }
            else
            {
                const auto range = juce::NormalisableRange<float> (s.min, s.max, s.step);
                layout.add (std::make_unique<juce::AudioParameterFloat> (pid, s.name, range, s.def));
            }
        }


        apvts = std::make_unique<juce::AudioProcessorValueTreeState> (*this, nullptr, "PARAMS", std::move (layout));
        
        paramAtomics.fill (nullptr);
        for (size_t i = 0; i < 64; ++i)
        {
            if (! sliderParamUsed[i]) continue;
            const auto& info = sliderParamInfo[i];
            paramAtomics[i] = apvts->getRawParameterValue (info.pid);
        }

        initStateMemory();
    }

    ~JSFXJuceProcessor() override
    {
        gMemOwner.erase (&st);
        gMemSize.erase (&st);
        if (st.mem) std::free (st.mem);
    }

    const juce::String getName() const override { return JucePlugin_Name; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}

    void prepareToPlay (double sampleRate, int) override
    {
        resetStateStructOnly();
        st.srate = sampleRate;

        jsfx_init (&st);

        // Push params and run @slider once at startup
        lastSlidersValid = false;
        (void) pushParamsToStateSliders();
        jsfx_slider(&st);
    }


    void releaseResources() override {}

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override
    {
        const auto in  = layouts.getMainInputChannelSet();
        const auto out = layouts.getMainOutputChannelSet();
        if (in.isDisabled() || out.isDisabled()) return false;
        if (in.size() != out.size()) return false;
        return (in.size() >= 1 && in.size() <= 64);
    }

    void processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override
    {
        juce::ScopedNoDenormals _;

        const int numCh = juce::jmin (buffer.getNumChannels(), 64);
        const int numSamples = buffer.getNumSamples();

        inPtrs.resize  ((size_t) numCh);
        outPtrs.resize ((size_t) numCh);

        for (int ch = 0; ch < numCh; ++ch)
        {
            inPtrs[(size_t) ch]  = buffer.getReadPointer (ch);
            outPtrs[(size_t) ch] = buffer.getWritePointer (ch);
        }        
        const bool slidersChanged = pushParamsToStateSliders();
        if (slidersChanged)
            jsfx_slider(&st);

        jsfx_process_block (&st, inPtrs.data(), outPtrs.data(), numCh, numSamples);

    }

    juce::AudioProcessorEditor* createEditor() override { return new juce::GenericAudioProcessorEditor (*this); }
    bool hasEditor() const override { return true; }

    void getStateInformation (juce::MemoryBlock& destData) override
    {
        auto tree = apvts->copyState();
        std::unique_ptr<juce::XmlElement> xml (tree.createXml());
        copyXmlToBinary (*xml, destData);
    }

    void setStateInformation (const void* data, int sizeInBytes) override
    {
        std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
        if (xml && xml->hasTagName (apvts->state.getType()))
            apvts->replaceState (juce::ValueTree::fromXml (*xml));
    }

private:
    void initStateMemory()
    {
        std::memset (&st, 0, sizeof (st));
        const int64_t initialN = 2048;
        st.mem  = (double*) std::calloc ((size_t) initialN, sizeof(double));
        st.memN = (st.mem != nullptr ? initialN : 0);

        gMemOwner[&st] = st.mem;
        gMemSize [&st] = st.memN;
    }

    void resetStateStructOnly()
    {
        double* memKeep = st.mem;
        int64_t memNKeep = st.memN;

        std::memset (&st, 0, sizeof (st));

        st.mem  = memKeep;
        st.memN = memNKeep;

        gMemOwner[&st] = st.mem;
        gMemSize [&st] = st.memN;
    }

    bool pushParamsToStateSliders()
    {
        bool changed = false;

        for (size_t i = 0; i < 64; ++i)
        {
            if (! sliderParamUsed[i])
                continue;

            const auto& info = sliderParamInfo[i];
            double newVal = st.sliders[i];

            // Robust value read:
            // - RangedAudioParameter::getValue() is ALWAYS normalised 0..1
            // - convertFrom0to1() ALWAYS returns the raw value in the parameter's declared range
            // This avoids accidentally feeding JSFX normalised values when the original slider
            // range was e.g. 0..100 or -24..+24.
            if (auto* v = paramAtomics[i])
            {
                // NOTE: For AudioParameterFloat, this returns the raw value in range.
                // For AudioParameterChoice, this returns the raw choice index.
                newVal = (double) v->load();
            }
            else if (auto* p = apvts->getParameter (info.pid))
            {
                const float norm = p->getValue();
                newVal = (double) p->convertFrom0to1 (norm);
            }

            // If the host-facing parameter is a CHOICE, its raw value is an index [0..N-1].
            // JSFX expects the original numeric slider value (min + index*step).
            if (info.isChoice)
                newVal = (double) info.min + std::llround (newVal) * (double) info.step;

            // Clamp to the declared JSFX range.
            newVal = juce::jlimit<double> ((double) info.min, (double) info.max, newVal);

            // If this slider is not a CHOICE, emulate JSFX slider stepping.
            // This prevents host float jitter from triggering @slider rebuilds.
            if (! info.isChoice)
            {
                const double step = (double) (info.step > 0.0f ? info.step : 0.0f);
                if (step > 0.0)
                {
                    const double q = std::llround ((newVal - (double) info.min) / step);
                    newVal = (double) info.min + q * step;

                    // clamp again after quantize
                    newVal = juce::jlimit<double> ((double) info.min, (double) info.max, newVal);
                }
            }

            // Detect actual value change
            if (!lastSlidersValid || newVal != lastSliders[i])
            {
                changed = true;
                lastSliders[i] = newVal;
            }

            st.sliders[i] = newVal;

        }

        lastSlidersValid = true;
        return changed;
    }



private:
    DSPJSFX_State st {};
    std::unique_ptr<juce::AudioProcessorValueTreeState> apvts;
    std::array<std::atomic<float>*, 64> paramAtomics {};

    std::vector<JsfxSliderDecl> sliderDecls;

    std::array<SliderParamInfo, 64> sliderParamInfo {};
    std::array<bool, 64>           sliderParamUsed {};

    std::vector<const float*> inPtrs;
    std::vector<float*> outPtrs;
    std::array<double, 64> lastSliders {};
    bool lastSlidersValid = false;

};


juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JSFXJuceProcessor();
}
